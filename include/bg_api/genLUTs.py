import requests
import json
from datetime import datetime as dt

spot = requests.get("https://api.bitget.com/api/spot/v1/public/products")
futures_umcbl = requests.get("https://api.bitget.com/api/mix/v1/market/contracts", params={'productType':'umcbl'})
futures_dmcbl = requests.get("https://api.bitget.com/api/mix/v1/market/contracts", params={'productType':'dmcbl'})
futures_cmcbl = requests.get("https://api.bitget.com/api/mix/v1/market/contracts", params={'productType':'cmcbl'})
futures_sumcbl = requests.get("https://api.bitget.com/api/mix/v1/market/contracts", params={'productType':'sumcbl'})
futures_sdmcbl = requests.get("https://api.bitget.com/api/mix/v1/market/contracts", params={'productType':'sdmcbl'})
futures_scmcbl = requests.get("https://api.bitget.com/api/mix/v1/market/contracts", params={'productType':'scmcbl'})
spot_msg = json.loads(spot.text)
umcbl_msg = json.loads(futures_umcbl.text)
dmcbl_msg = json.loads(futures_dmcbl.text)
cmcbl_msg = json.loads(futures_cmcbl.text)
sumcbl_msg = json.loads(futures_sumcbl.text)
sdmcbl_msg = json.loads(futures_sdmcbl.text)
scmcbl_msg = json.loads(futures_scmcbl.text)
num_spot = len(spot_msg['data'])
num_umcbl = len(umcbl_msg['data'])
num_dmcbl = len(dmcbl_msg['data'])
num_cmcbl = len(cmcbl_msg['data'])
num_sumcbl = len(sumcbl_msg['data'])
num_sdmcbl = len(sdmcbl_msg['data'])
num_scmcbl = len(scmcbl_msg['data'])

spot_func_to_prop = {
    'getSpotMinTradeAmt':('double_type','minTradeAmount'),
    'getSpotMaxTradeAmt':('double_type','maxTradeAmount'),
    'getSpotTakerFeeRate':('double_type','takerFeeRate'),
    'getSpotMakerFeeRate':('double_type','makerFeeRate'),
    'getSpotPriceScale':('unsigned int','priceScale'),
    'getSpotQtyScale':('unsigned int','quantityScale'),
    'getSpotMinTradeUSDT':('double_type','minTradeUSDT')
}

def genSpotSearches() -> str:
    out_str = ""
    for f in spot_func_to_prop:
        _type = spot_func_to_prop.get(f)[0]
        _attr = spot_func_to_prop.get(f)[1]
        param1 = f"{_type} {f}(const char* const sym)" + " {\n"
        param1 += "\tint i = getSymbolIndex(sym);\n"
        param1 += "\tif (i == -1)\n"
        param1 += "\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n"
        param1 += "\t" + f"return spotLUT[i].{_attr};" + "\n}\n\n"

        param2 = f"{_type} {f}(const char* const base, const char* const quote)" + " {\n"
        param2 += "\tint i = getSymbolIndex(base, quote);\n"
        param2 += "\tif (i == -1)\n"
        param2 += "\t\tthrow std::invalid_argument(\"\\\'base\\\' and/or \\\'quote\\\' must be a valid coin\");\n"
        param2 += "\t" + f"return spotLUT[i].{_attr};" + "\n}\n\n"

        out_str += param1 + param2

    return out_str


with open('LUTs.cpp', 'w') as fp:
    # Write the include(s), define(s), and namespace declaration(s)
    fp.write(f"// Generated by genLUTs.py on {dt.now():%Y-%m-%d %H:%M:%S} EST\n")
    fp.write("#include <stdexcept>\n")
    fp.write("#include <string.h>\n")
    fp.write("#include \"LUTs.hpp\"\n\n")
    fp.write(f"#define NUM_SPOT {num_spot}\n")
    fp.write(f"#define NUM_UMCBL {num_umcbl}\n")
    fp.write(f"#define NUM_DMCBL {num_dmcbl}\n")
    fp.write(f"#define NUM_CMCBL {num_cmcbl}\n")
    fp.write(f"#define NUM_SUMCBL {num_sumcbl}\n")
    fp.write(f"#define NUM_SDMCBL {num_sdmcbl}\n")
    fp.write(f"#define NUM_SCMCBL {num_scmcbl}\n\n")
    fp.write("namespace bg_api {\n\n")

    # Create the spot LUT
    fp.write("static spot_coin_info spotLUT[NUM_SPOT] = {\n")
    for coin in spot_msg['data'][:-1]: # Loop through spot pairs
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", \"{coin['symbolName']}\", \"{coin['baseCoin']}\", \"{coin['quoteCoin']}\", {coin['minTradeAmount']}, {coin['maxTradeAmount']}, ")
        fp.write(f"{coin['takerFeeRate']}, {coin['makerFeeRate']}, {coin['priceScale']}, {coin['makerFeeRate']}, {coin['minTradeUSDT']}")
        fp.write("},\n")
    spot_coin = spot_msg['data'][len(spot_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{coin['symbol']}\", \"{coin['symbolName']}\", \"{coin['baseCoin']}\", \"{coin['quoteCoin']}\", {coin['minTradeAmount']}, {coin['maxTradeAmount']}, ")
    fp.write(f"{coin['takerFeeRate']}, {coin['makerFeeRate']}, {coin['priceScale']}, {coin['makerFeeRate']}, {coin['minTradeUSDT']}")
    fp.write("}\n};\n\n")

    # Create the futures LUTs
    # umcblLUT
    fp.write("static futures_coin_info umcblLUT[NUM_UMCBL] = {\n")
    for coin in umcbl_msg['data'][:-1]:  # Loop through UMCBL contracts
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", {coin['makerFeeRate']}, {coin['takerFeeRate']}, {coin['feeRateUpRatio']}, {coin['openCostUpRatio']}, ")
        fp.write(f"{coin['buyLimitPriceRatio']}, {coin['sellLimitPriceRatio']}, {coin['minTradeNum']}, {coin['priceEndStep']}, ")
        fp.write(f"{coin['volumePlace']}, {coin['pricePlace']}, {coin['sizeMultiplier']}")
        fp.write("},\n")
    futures_coin = umcbl_msg['data'][len(umcbl_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{futures_coin['symbol']}\", {futures_coin['makerFeeRate']}, {futures_coin['takerFeeRate']}, {futures_coin['feeRateUpRatio']}, {futures_coin['openCostUpRatio']}, ")
    fp.write(f"{futures_coin['buyLimitPriceRatio']}, {futures_coin['sellLimitPriceRatio']}, {futures_coin['minTradeNum']}, {futures_coin['priceEndStep']}, ")
    fp.write(f"{futures_coin['volumePlace']}, {futures_coin['pricePlace']}, {futures_coin['sizeMultiplier']}")
    fp.write("}\n};\n\n")
    
    # dmcblLUT
    fp.write("static futures_coin_info dmcblLUT[NUM_DMCBL] = {\n")
    for coin in dmcbl_msg['data'][:-1]:  # Loop through DMCBL contracts
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", {coin['makerFeeRate']}, {coin['takerFeeRate']}, {coin['feeRateUpRatio']}, {coin['openCostUpRatio']}, ")
        fp.write(f"{coin['buyLimitPriceRatio']}, {coin['sellLimitPriceRatio']}, {coin['minTradeNum']}, {coin['priceEndStep']}, ")
        fp.write(f"{coin['volumePlace']}, {coin['pricePlace']}, {coin['sizeMultiplier']}")
        fp.write("},\n")
    futures_coin = dmcbl_msg['data'][len(dmcbl_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{futures_coin['symbol']}\", {futures_coin['makerFeeRate']}, {futures_coin['takerFeeRate']}, {futures_coin['feeRateUpRatio']}, {futures_coin['openCostUpRatio']}, ")
    fp.write(f"{futures_coin['buyLimitPriceRatio']}, {futures_coin['sellLimitPriceRatio']}, {futures_coin['minTradeNum']}, {futures_coin['priceEndStep']}, ")
    fp.write(f"{futures_coin['volumePlace']}, {futures_coin['pricePlace']}, {futures_coin['sizeMultiplier']}")
    fp.write("}\n};\n\n")

    # cmcblLUT
    fp.write("static futures_coin_info cmcblLUT[NUM_CMCBL] = {\n")
    for coin in cmcbl_msg['data'][:-1]:  # Loop through CMCBL contracts
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", {coin['makerFeeRate']}, {coin['takerFeeRate']}, {coin['feeRateUpRatio']}, {coin['openCostUpRatio']}, ")
        fp.write(f"{coin['buyLimitPriceRatio']}, {coin['sellLimitPriceRatio']}, {coin['minTradeNum']}, {coin['priceEndStep']}, ")
        fp.write(f"{coin['volumePlace']}, {coin['pricePlace']}, {coin['sizeMultiplier']}")
        fp.write("},\n")
    futures_coin = cmcbl_msg['data'][len(cmcbl_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{futures_coin['symbol']}\", {futures_coin['makerFeeRate']}, {futures_coin['takerFeeRate']}, {futures_coin['feeRateUpRatio']}, {futures_coin['openCostUpRatio']}, ")
    fp.write(f"{futures_coin['buyLimitPriceRatio']}, {futures_coin['sellLimitPriceRatio']}, {futures_coin['minTradeNum']}, {futures_coin['priceEndStep']}, ")
    fp.write(f"{futures_coin['volumePlace']}, {futures_coin['pricePlace']}, {futures_coin['sizeMultiplier']}")
    fp.write("}\n};\n\n")

    # sumcblLUT
    fp.write("static futures_coin_info sumcblLUT[NUM_SUMCBL] = {\n")
    for coin in sumcbl_msg['data'][:-1]:  # Loop through SUMCBL contracts
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", {coin['makerFeeRate']}, {coin['takerFeeRate']}, {coin['feeRateUpRatio']}, {coin['openCostUpRatio']}, ")
        fp.write(f"{coin['buyLimitPriceRatio']}, {coin['sellLimitPriceRatio']}, {coin['minTradeNum']}, {coin['priceEndStep']}, ")
        fp.write(f"{coin['volumePlace']}, {coin['pricePlace']}, {coin['sizeMultiplier']}")
        fp.write("},\n")
    futures_coin = sumcbl_msg['data'][len(sumcbl_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{futures_coin['symbol']}\", {futures_coin['makerFeeRate']}, {futures_coin['takerFeeRate']}, {futures_coin['feeRateUpRatio']}, {futures_coin['openCostUpRatio']}, ")
    fp.write(f"{futures_coin['buyLimitPriceRatio']}, {futures_coin['sellLimitPriceRatio']}, {futures_coin['minTradeNum']}, {futures_coin['priceEndStep']}, ")
    fp.write(f"{futures_coin['volumePlace']}, {futures_coin['pricePlace']}, {futures_coin['sizeMultiplier']}")
    fp.write("}\n};\n\n")

    # sdmcblLUT
    fp.write("static futures_coin_info sdmcblLUT[NUM_SDMCBL] = {\n")
    for coin in sdmcbl_msg['data'][:-1]:  # Loop through SDMCBL contracts
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", {coin['makerFeeRate']}, {coin['takerFeeRate']}, {coin['feeRateUpRatio']}, {coin['openCostUpRatio']}, ")
        fp.write(f"{coin['buyLimitPriceRatio']}, {coin['sellLimitPriceRatio']}, {coin['minTradeNum']}, {coin['priceEndStep']}, ")
        fp.write(f"{coin['volumePlace']}, {coin['pricePlace']}, {coin['sizeMultiplier']}")
        fp.write("},\n")
    futures_coin = sdmcbl_msg['data'][len(sdmcbl_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{futures_coin['symbol']}\", {futures_coin['makerFeeRate']}, {futures_coin['takerFeeRate']}, {futures_coin['feeRateUpRatio']}, {futures_coin['openCostUpRatio']}, ")
    fp.write(f"{futures_coin['buyLimitPriceRatio']}, {futures_coin['sellLimitPriceRatio']}, {futures_coin['minTradeNum']}, {futures_coin['priceEndStep']}, ")
    fp.write(f"{futures_coin['volumePlace']}, {futures_coin['pricePlace']}, {futures_coin['sizeMultiplier']}")
    fp.write("}\n};\n\n")

    # scmcblLUT
    fp.write("static futures_coin_info scmcblLUT[NUM_SCMCBL] = {\n")
    for coin in scmcbl_msg['data'][:-1]:  # Loop through SCMCBL contracts
        fp.write("\t{")
        fp.write(f"\"{coin['symbol']}\", {coin['makerFeeRate']}, {coin['takerFeeRate']}, {coin['feeRateUpRatio']}, {coin['openCostUpRatio']}, ")
        fp.write(f"{coin['buyLimitPriceRatio']}, {coin['sellLimitPriceRatio']}, {coin['minTradeNum']}, {coin['priceEndStep']}, ")
        fp.write(f"{coin['volumePlace']}, {coin['pricePlace']}, {coin['sizeMultiplier']}")
        fp.write("},\n")
    futures_coin = scmcbl_msg['data'][len(scmcbl_msg['data']) - 1]
    fp.write("\t{")
    fp.write(f"\"{futures_coin['symbol']}\", {futures_coin['makerFeeRate']}, {futures_coin['takerFeeRate']}, {futures_coin['feeRateUpRatio']}, {futures_coin['openCostUpRatio']}, ")
    fp.write(f"{futures_coin['buyLimitPriceRatio']}, {futures_coin['sellLimitPriceRatio']}, {futures_coin['minTradeNum']}, {futures_coin['priceEndStep']}, ")
    fp.write(f"{futures_coin['volumePlace']}, {futures_coin['pricePlace']}, {futures_coin['sizeMultiplier']}")
    fp.write("}\n};\n\n")

    # Implement spot methods
    # getSpotSymbolIndex
    fp.write("int getSymbolIndex(const char* const sym) {\n")
    fp.write("\tfor (int i = 0; i < NUM_SPOT; i++) {\n")
    fp.write("\t\tif (strcmp(spotLUT[i].symbol, sym) == 0 || strcmp(spotLUT[i].symbolName, sym) == 0)\n")
    fp.write("\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n")

    # getSpotSymbolIndex (2 params)
    fp.write("int getSymbolIndex(const char* const base, const char* const quote) {\n")
    fp.write("\tfor (int i = 0; i < NUM_SPOT; i++) {\n")
    fp.write("\t\tif (strcmp(spotLUT[i].baseCoin, base) == 0 && strcmp(spotLUT[i].quoteCoin, quote) == 0)\n")
    fp.write("\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n")

    # Generate other spot methods
    fp.write(genSpotSearches())

    # Implement futures methods
    # getFuturesMakerFeeRate
    fp.write("double_type getFuturesMakerFeeRate(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].makerFeeRate;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].makerFeeRate;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].makerFeeRate;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].makerFeeRate;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].makerFeeRate;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].makerFeeRate;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesTakerFeeRate
    fp.write("double_type getFuturesTakerFeeRate(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].takerFeeRate;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].takerFeeRate;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].takerFeeRate;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].takerFeeRate;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].takerFeeRate;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].takerFeeRate;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesFeeRateUpRatio
    fp.write("double_type getFuturesFeeRateUpRatio(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].feeRateUpRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].feeRateUpRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].feeRateUpRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].feeRateUpRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].feeRateUpRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].feeRateUpRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesOpenCostUpRatio
    fp.write("double_type getFuturesOpenCostUpRatio(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].openCostUpRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].openCostUpRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].openCostUpRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].openCostUpRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].openCostUpRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].openCostUpRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesBuyLimitPriceRatio
    fp.write("double_type getFuturesBuyLimitPriceRatio(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].buyLimitPriceRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].buyLimitPriceRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].buyLimitPriceRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].buyLimitPriceRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].buyLimitPriceRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].buyLimitPriceRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesSellLimitPriceRatio
    fp.write("double_type getFuturesSellLimitPriceRatio(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].sellLimitPriceRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].sellLimitPriceRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].sellLimitPriceRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].sellLimitPriceRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].sellLimitPriceRatio;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].sellLimitPriceRatio;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesMinTradeNum
    fp.write("double_type getFuturesMinTradeNum(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].minTradeNum;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].minTradeNum;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].minTradeNum;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].minTradeNum;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].minTradeNum;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].minTradeNum;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesPriceEndStep
    fp.write("unsigned int getFuturesPriceEndStep(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].priceEndStep;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].priceEndStep;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].priceEndStep;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].priceEndStep;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].priceEndStep;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].priceEndStep;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesVolumePlace
    fp.write("unsigned int getFuturesVolumePlace(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].volumePlace;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].volumePlace;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].volumePlace;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].volumePlace;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].volumePlace;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].volumePlace;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesPricePlace
    fp.write("unsigned int getFuturesPricePlace(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].pricePlace;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].pricePlace;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].pricePlace;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].pricePlace;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].pricePlace;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].pricePlace;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    # getFuturesSizeMultiplier
    fp.write("double_type getFuturesSizeMultiplier(const char* const sym) {\n")
    fp.write("\tstd::size_t len = strlen(sym);\n")
    fp.write("\tswitch (sym[len-5]) {\n")
    fp.write("\t\tcase \'u\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SUMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sumcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sumcblLUT[i].sizeMultiplier;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_UMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(umcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn umcblLUT[i].sizeMultiplier;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'d\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SDMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(sdmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn sdmcblLUT[i].sizeMultiplier;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_DMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(dmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn dmcblLUT[i].sizeMultiplier;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\tcase \'c\':\n")
    fp.write("\t\t\tif (sym[len-6] == \'s\')\n")
    fp.write("\t\t\t\tfor (int i = 0; i < NUM_SCMCBL; i++) {\n")
    fp.write("\t\t\t\t\tif (strcmp(scmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\t\treturn scmcblLUT[i].sizeMultiplier;\n")
    fp.write("\t\t\t\t}\n")
    fp.write("\t\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n")
    fp.write("\t\t\tfor (int i = 0; i < NUM_CMCBL; i++) {\n")
    fp.write("\t\t\t\tif (strcmp(cmcblLUT[i].symbol, sym) == 0)\n")
    fp.write("\t\t\t\t\treturn cmcblLUT[i].sizeMultiplier;\n")
    fp.write("\t\t\t}\n")
    fp.write("\t\tdefault:\n")
    fp.write("\t\t\tthrow std::invalid_argument(\"\\\'sym\\\' must be a valid coin\");\n\t}\n}\n\n")

    fp.write("} // bg_api")

print("-- Lookup tables done")